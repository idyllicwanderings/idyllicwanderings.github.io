{"pages":[],"posts":[{"title":"Protocols&#39;","text":"[TOC] 网际层ARP协议通常ARP的攻击是只针对内网主机的，可以通过伪造内网ip和欺骗内网主机的目的MAC地址来进行攻击，后者常常被称为ARP欺骗。 解决方法： 交换机配置802.1x协议，需要对用户进行授权和登录。 建立静态ARP协议表（不建议）。 IP协议 容易被监听、窃取：加密传输。 恶意篡改：完整性检测机制。 ip欺骗攻击（即更改source ip）：源地址鉴别机制。 ip分段重组中在包过滤器注入大量病态小数据报：防火墙能够重组分段的IP数据包，以检查其内容。 定向目的地址（比如广播）：部分路由器可以组织某些特殊的destination ip address。 ICMP协议ICMP是一个重要的错误处理和信息处理协议。通知到底目的地的最佳路由，路由故障或者因网络故障终端某个连接。（ping , tracert)。 主要存在攻击如下： 重定向攻击。 ICMP 重定向消息：如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个 ICMP 重定向消息给这个主机，这个消息包含了最合适的路由信息和源数据。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个 ICMP 重定向消息给发送端主机一个更合适的发送路由。 实验代码参考：https://cloud.tencent.com/developer/article/1396117 路由发现攻击。由于应答时不对应答方进行身份印证，黑客又可能冒充路由器伪造路由信息。 防火墙穿越攻击。攻击者通过获取某个防火墙的规则集和访问控制列表。 IGMP协议ip组播管理协议。IGMP组播报文在IP数据包的基础上封装了组播地址等信息，鉴于组播报文基于UDP进行传输并且缺少用户认证措施，网络中任何主机都可以向组播路由器发送IGMP包，请求加入或者离开，导致非法用户很容易加入组播组。主要攻击有以下几种： 利用查询报文攻击。 离开报文进行DOS攻击。 通常使用IGMP v3解决上述问题。 RIP协议 RIPv1采用UDP协议进行传输，RIPv2的分组格式中包含了一个选项可以设置16个字符的明文加密字符串或者对MD5杂凑值的签名。虽然RIP报文很容易伪造，但是RIPv2对签名与认证是的欺骗的操作难度大大提高。 OSPF协议OSPF的报文中包含中·认证类型以及认证数据字段，其中主要密码认证、空认证以及明文认证3中认证模式。 在OSPF中，欺骗会得到扩散。 BGP协议BG缺乏一种可靠的路由认证机制。通常通过两类方案解决： 路由认证类方案（数字证书、签名和其他密码学技术）： 针对劫持BGP TCP会话的MD5 BGP 认证技术。 S-BGP方案利用PKI技术增强BGP的安全性。 前缀劫持检测类方案： 多源AS检测技术。 主动探测技术。 传输层UDP协议DoS攻击是一种最常见的UDP攻击，而UDP Flood攻击又是DoS攻击中最普遍的流量型攻击。 原理：UDP Flood主要通过利用服务器响应发送到其中一个端口的UDP数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到UDP数据包时，会经过两个步骤。1. 服务器首先检查是否正在运行正在侦听指定端口的请求的程序。2. 如果没有程序在该端口接收数据包，则服务器使用ICMP（ping）数据包进行响应，以通知发送方目的地不可达。 实现的参考链接：https://blog.csdn.net/hwhaocool/article/details/29919267?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1 TCP协议三类攻击： 针对TCP连接建立阶段的三次握手过程。最常见的就是SYN FLOOD攻击： 攻击者发送大量的SYN包，服务器回应(SYN+ACK)包，但是攻击者不回应ACK包，这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。 参考链接：https://www.cnblogs.com/sunsky303/p/11811097.html 针对TCP协议不对数据包进行加密和认证的漏洞，进行TCP会话劫持攻击。攻击者通过猜测序列号来伪造合法（在有效接收窗口内的）报文。 针对TCP拥塞控制机制的特性。 应用层HTTP协议数据直接通过明文进行传输，有较大的安全缺陷。此外HTTP协议唯一的完整性检测就是在报文头部包含买了数据传输长度，而没有对数据传输内容进行完整性检测。 HTTPS协议增加了TCP和HTTP之间的安全层，主要用SSL和TLS实现。 DNS协议\\1) 域名劫持 通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的NS纪录指向到黑客可以控制的DNS服务器，然后通过在该DNS服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。 这显然是DNS服务提供商的责任，用户束手无策。 2) 缓存投毒 利用控制DNS缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。其实现方式有多种，比如可以通过利用网民ISP端的DNS缓存服务器的漏洞进行攻击或控制，从而改变该ISP内的用户访问域名的响应结果;或者，黑客通过利用用户权威域名服务器上的漏洞，如当用户权威域名服务器同时可以被当作缓存服务器使用，黑客可以实现缓存投毒，将错误的域名纪录存入缓存中，从而使所有使用该缓存服务器的用户得到错误的DNS解析结果。 最近发现的DNS重大缺陷，就是这种方式的。只所以说是“重大”缺陷，据报道是因为是协议自身的设计实现问题造成的，几乎所有的DNS软件都存在这样的问题。 3)DDOS攻击 一种攻击针对DNS服务器软件本身，通常利用BIND软件程序中的漏洞，导致DNS服务器崩溃或拒绝服务;另一种攻击的目标不是DNS服务器，而是利用DNS服务器作为中间的“攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。 4) DNS欺骗 DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。 现在的Internet上存在的DNS服务器有绝大多数都是用bind来架设的,使用的bind版本主要为bind 4.9.5+P1以前版本和bind 8.2.2-P5以前版本.这些bind有个共同的特点,就是BIND会缓存(Cache)所有已经查询过的结果,这个问题就引起了下面的几个问题的存在. TELNET协议TELNET协议是一种明文协议，明文传输用户的通信内容，包括用户名和密码。主要有两类安全问题： 攻击者可以通过sniffer监听会话。 主动攻击，比如在认证完成后旋盖或者插入一些命令。 SSH协议安全壳（Secure Shell）协议是一种在不安全的网络上建立安全的远程登录或者其他安全网络服务的协议.SSH对所有传输的数据使用RSA公钥加密算法进行处理。 SSH协议框架中最主要的部分是三个协议： 传输层协议（The Transport Layer Protocol）提供服务器认证，数据机密性，信息完整性等的支持 用户认证协议（The User Authentication Protocol） 则为服务器提供客户端的身份鉴别 连接协议（The Connection Protocol） 将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用； 各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制。 存在的问题： 服务器认证。 协议版本协商。 主机密钥文件安全。 SMTP协议MIME协议POP3协议IMAP4协议PGP协议FTP协议TFTP协议NSF协议SNMP协议DHCP协议SIP协议NTP协议FINGER协议Whois协议LDAP协议NNTP协议参考《网络安全：技术与实践》 清华出版社","link":"/2020/06/30/Protocols/"},{"title":"Lattice","text":"Lattice Cryptography","link":"/2022/03/30/Lattice%20Cryptography/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/31/hello-world/"},{"title":"packing","text":"coding- 关于packing当我们在 bash 中运行一个动态链接的 elf 文件的时候，会发生以下事情。 - 系统调用 fork 不是重点，简单说说。对于 x86 32 位，执行 int 0x80 中断，eax 存系统调用号，ebx，ecx，edx，esi，edi 存参数，调用 copy process，创建 task struct，复制页表，设置子进程寄存器的值（尤其是 eax 设置成 0），设置子进程运行状态，等等。 - 系统调用 exec 先查找要执行的文件，读取前 128 字节，根据文件开头的魔数判断文件类型。然后调用 search binary handle 执行相应文件类型的装载过程。如果是 elf 文件的话，会去调用 load elf binary。 然后，load elf binary 去找 elf 文件的 .interp 段，这个段存储了动态链接器的软链接（软链接为了升级方便）；再去根据 elf 文件的程序头表（程序头表存储了可执行文件的 segment 信息，segment 是由相同权限的 section 合并而来），对 elf 文件进行映射（这里的映射是有可以省物理内存的小技巧的。我们可以把所有需要映射的 segment 连在一起划分成一个个物理页，如果一个物理页跨了两个 segment，可以将跨 segment 的物理页向地址空间映射两次，一次当成 A segment，一次当成 B segment，会少很多内部碎片）；执行一系列我们不关心的初始化工作；将 exec 返回的地址改成动态链接器的入口点 start 函数。 - 动态链接器启动 其实在动态链接器启动之前，操作系统会把动态链接器用得到的参数压栈，例如动态链接器的加载地址，可执行文件的入口地址，可执行文件的 fd 之类的。这里我们不是很关心。还有几个关于动态链接器的问题，即：动态链接器也是共享对象，它的加载地址是内核决定的；动态链接器不动态链接其它的库，即它是静态链接的，因为它本身就是所有动态链接的源头。 那么，动态链接器的重定位要由它自己完成，所以动态链接器最开始先要进行一个自举的操作，它需要找到自己的 .dynamic 段，由此获得自己的符号表和重定位表，将自己所有的重定位入口都重定位了之后，动态链接器就可以正常工作了。 - 动态链接器工作 动态链接器根据可执行文件中的 .dynamic 段的信息，找出这个可执行文件依赖哪些共享对象，把它们记到一个装载集合中，然后找到依赖的共享对象的文件，打开它们，查看它们的 .dynamic 段，再看看它们依赖哪些共享对象，加入装载集合中，再找到这些共享对象，如此递归下去。比较常见的算法一般是广度优先的。当一个共享对象被加载进来的时候，它的符号表会和大家合并到一起去，形成全局符号表。 等到所有的共享对象都加载完毕之后，动态链接器会遍历可执行文件和每一个共享对象的重定位表（.rel.dyn 和 .rel.plt），根据全局符号表重定位每一个重定位入口。主要是修正 got 段和 plt 段的代码。这里我们就要涉及地址无关的概念了。 动态链接的好处自然是可以省物理内存。但是动态链接库在不同的进程地址空间上映射的虚拟地址是不同的，所以一些需要重定位的地址也是不同的。这样的话，每个进程重定位之后的代码段互不相同。这样是不能共享代码段的。我们考虑把需要重定位的数据和函数调用的地址都提取出来，放在一个表里（这个表的每一个 entry 的顺序自然是规定好的）。我们访问需要重定位的数据或函数调用的时候，就去查这个表就好了。这样，代码段都是相同的，只有这个表中的地址不同。就可以共享内存了。这个表就是 got 表。我们还有一个问题，即，我们的可执行文件中并不是每一个动态链接库中的函数都会使用到，那么重定位其实可以延迟到真正使用这个函数的时候。这个技术就叫 plt，使用了 plt 表。 具体实现方式是这样的。我们有一个 plt 表。例如我们有 foo 函数，那么 foo@plt 是这样实现的。 1234jump *(foo@got)push index_in_relpush module_idjump _dl_runtime_resolve 在动态链接器初始化的 plt 的时候，会把 foo@got 这个地址设置成 push index in rel 指令的地址（也就是说啥也不干直接往后执行），其他的啥也不干。如果真的用到了这个函数，那么会执行两个 push 以及这个 dl runtime resolve 函数，它会去重定位 foo，并且把 foo@got 填对，那么以后再跳到 foo@plt 的时候，就会直接跳到 foo@got 了，不会再走两个 push 和 dl runtime resolve 函数了。这就实现了延迟绑定的效果。 动态链接器把所有重定位入口重定位完之后，对于所有共享对象，如果其有 .init 段，那么执行这个段的代码（共享对象中的初始化操作，例如全局变量的构造函数之类的）。注意可执行文件的 .init 段，动态链接器是不会执行的，这段代码由可执行文件自己执行。在这之后，动态链接器结束了它的工作，把程序跳转到了可执行文件的 start 函数。 - 可执行文件开始执行 在调用可执行文件的 start 前，装载器会将 argv 和 env 压入栈中。首先，start 会设置 ebp 并且压入 esi（就是 argc），然后调用 libc start main 函数，这个函数：在一个链表中注册了 rtld fini（用于共享对象的收尾工作，例如执行共享对象中的全局变量的析构）以及 fini（用于可执行文件的收尾工作，例如可执行文件中的全局变量的析构）；执行 init 函数（可执行文件的 .init 段中的函数，用于初始化，例如可执行文件中的全局变量的构造）；执行 main 函数主体；执行 exit 函数，调用链表中所有注册的函数（默认有两个，即上文说的 rtld fini 和 fini）；最后执行 exit 系统调用退出。 加壳程序： 12345678910111213141516171819202122int _tmain(int argc, _TCHAR* argv[]){ char* szShell = &quot;../Debug/shell.exe&quot;; char* szObj = &quot;../Debug/xxx.exe&quot;; HPE shell = loadPE(szShell); HPE object = loadPE(szObj); int length = getFileLength(object); BYTE* src = getFileBuffer(object); HPE newObj = addSection(shell, &quot;.src&quot;, length + 0x2000, 0x60000020); IMAGE_OPTIONAL_HEADER32* pOptionalHeader = getOptionalHeader(newObj); IMAGE_SECTION_HEADER* pShellSection = getLastSection(newObj); pOptionalHeader-&gt;AddressOfEntryPoint = pShellSection-&gt;VirtualAddress; memcpy((void*)(pShellSection-&gt;PointerToRawData + (int)getFileBuffer(newObj)), myshellcode, sizeof(myshellcode)); memcpy((void*)(pShellSection-&gt;PointerToRawData + (int)getFileBuffer(newObj) + 0x2000), src, length); writeFile(&quot;../Debug/test.exe&quot;, newObj); releasePE(newObj); return 0;} 脱壳程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189void Decrypt(){ BOOL bResult = TRUE; HANDLE hProcess = NULL; TERMINATEPROCESS TerminateProcess = NULL; try { HINSTANCE hKernel32 = NULL; __asm { push eax mov eax, fs:[0x30] // PEB mov eax, [eax + 0x0c] // LDR mov eax, [eax + 0x0c] // 本进程模块, LDA_DATA_TABLE_ENTRY 结构 mov eax, [eax] // ntdll 模块 mov eax, [eax] // kernel32 模块 mov eax, [eax + 0x18] // dllBase mov hKernel32, eax pop eax } char szGetProcAddress[] = { 'G', 'e', 't', 'P', 'r', 'o', 'c', 'A', 'd', 'd', 'r', 'e', 's', 's', '\\0' }; GETPROCADDRESS GetProcAddress = NULL; // 在 kernel32中寻找 GetProcAddress 函数 IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)hKernel32; IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)((DWORD)hKernel32 + pDosHeader-&gt;e_lfanew); IMAGE_EXPORT_DIRECTORY* pExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((DWORD)hKernel32 + pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); short* functionOrdinals = (short*)((DWORD)hKernel32 + pExportDirectory-&gt;AddressOfNameOrdinals); int* adddressOfNames = (int*)((DWORD)hKernel32 + pExportDirectory-&gt;AddressOfNames); int* addressOfFunctions = (int*)((DWORD)hKernel32 + pExportDirectory-&gt;AddressOfFunctions); for (int i = 0; i &lt; pExportDirectory-&gt;NumberOfNames; ++i) { // 第 i 个函数名地址 char* name = (char*)((DWORD)hKernel32 + adddressOfNames[i]); char* left = name; char* right = szGetProcAddress; bool res = true; while (*left || *right) { if (*left != *right) { res = false; break; } ++left; ++right; } if (res) { GetProcAddress = (GETPROCADDRESS)((DWORD)hKernel32 + addressOfFunctions[functionOrdinals[i]]); break; } } pDosHeader = NULL; pNtHeader = NULL; char szLoadLibrary[] = { 'L', 'o', 'a', 'd', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'A', '\\0' }; char szGetModuleHandle[] = { 'G', 'e', 't', 'M', 'o', 'd', 'u', 'l', 'e', 'H', 'a', 'n', 'd', 'l', 'e', 'A', '\\0' }; char szCreateProcess[] = { 'C', 'r', 'e', 'a', 't', 'e', 'P', 'r', 'o', 'c', 'e', 's', 's', 'A', '\\0' }; char szGetModuleFileName[] = { 'G', 'e', 't', 'M', 'o', 'd', 'u', 'l', 'e', 'F', 'i', 'l', 'e', 'N', 'a', 'm', 'e', 'A', '\\0' }; char szGetThreadContext[] = { 'G', 'e', 't', 'T', 'h', 'r', 'e', 'a', 'd', 'C', 'o', 'n', 't', 'e', 'x', 't', '\\0'}; char szReadProcessMemory[] = { 'R', 'e', 'a', 'd', 'P', 'r', 'o', 'c', 'e', 's', 's', 'M', 'e', 'm', 'o', 'r', 'y', '\\0' }; char szZwUnmapViewOfSection[] = { 'Z', 'w', 'U', 'n', 'm', 'a', 'p', 'V', 'i', 'e', 'w', 'O', 'f', 'S', 'e', 'c', 't', 'i', 'o', 'n', '\\0' }; char szNtDll[] = { 'n', 't', 'd', 'l', 'l', '.', 'd', 'l', 'l', '\\0' }; char szMemcpy[] = { 'm', 'e', 'm', 'c', 'p', 'y', '\\0' }; char szMemset[] = { 'm', 'e', 'm', 's', 'e', 't', '\\0' }; char szMSVCRT[] = { 'm', 's', 'v', 'c', 'r', 't', '.', 'd', 'l', 'l', '\\0' }; char szMalloc[] = { 'm', 'a', 'l', 'l', 'o', 'c', '\\0' }; char szFree[] = { 'f', 'r', 'e', 'e', '\\0' }; char szVirtualAllocEx[] = { 'V', 'i', 'r', 't', 'u', 'a', 'l', 'A', 'l', 'l', 'o', 'c', 'E', 'x', '\\0' }; char szWriteProcessMemory[] = { 'W', 'r', 'i', 't', 'e', 'P', 'r', 'o', 'c', 'e', 's', 's', 'M', 'e', 'm', 'o', 'r', 'y', '\\0' }; char szSetThreadContext[] = { 'S', 'e', 't', 'T', 'h', 'r', 'e', 'a', 'd', 'C', 'o', 'n', 't', 'e', 'x', 't', '\\0' }; char szResumeThread[] = { 'R', 'e', 's', 'u', 'm', 'e', 'T', 'h', 'r', 'e', 'a', 'd', '\\0' }; char szTerminateProcess[] = { 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'P', 'r', 'o', 'c', 'e', 's', 's', '\\0' }; char szExitProcess[] = { 'E', 'x', 'i', 't', 'P', 'r', 'o', 'c', 'e', 's', 's', '\\0' }; LOADLIBRARY LoadLibraryA = (LOADLIBRARY)GetProcAddress(hKernel32, szLoadLibrary); GETMODULEHANDLE GetModuleHandleA = (GETMODULEHANDLE)GetProcAddress(hKernel32, szGetModuleHandle); CREATEPROCESS CreateProcessA = (CREATEPROCESS)GetProcAddress(hKernel32, szCreateProcess); GETMODULEFILENAME GetModuleFileNameA = (GETMODULEFILENAME)GetProcAddress(hKernel32, szGetModuleFileName); GETTHREADCONTEXT GetThreadContext = (GETTHREADCONTEXT)GetProcAddress(hKernel32, szGetThreadContext); READPROCESSMEMORY ReadProcessMemory = (READPROCESSMEMORY)GetProcAddress(hKernel32, szReadProcessMemory); WRITEPROCESSMEMORY WriteProcessMemory = (WRITEPROCESSMEMORY)GetProcAddress(hKernel32, szWriteProcessMemory); VIRTUALALLOCEX VirtualAllocEx = (VIRTUALALLOCEX)GetProcAddress(hKernel32, szVirtualAllocEx); SETTHREADCONTEXT SetThreadContext = (SETTHREADCONTEXT)GetProcAddress(hKernel32, szSetThreadContext); RESUMETHREAD ResumeThread = (RESUMETHREAD)GetProcAddress(hKernel32, szResumeThread); TerminateProcess = (TERMINATEPROCESS)GetProcAddress(hKernel32, szTerminateProcess); EXITPROCESS ExitProcess = (EXITPROCESS)GetProcAddress(hKernel32, szExitProcess); HMODULE hNtDll = GetModuleHandleA(szNtDll); ZWUNMAPVIEWOFSECTION ZwUnmapViewOfSection = (ZWUNMAPVIEWOFSECTION)GetProcAddress(hNtDll, szZwUnmapViewOfSection); MEMCPY memcpy = (MEMCPY)GetProcAddress(hNtDll, szMemcpy); MEMSET memset = (MEMSET)GetProcAddress(hNtDll, szMemset); HMODULE hMSVCRT = LoadLibraryA(szMSVCRT); MALLOC malloc = (MALLOC)GetProcAddress(hMSVCRT, szMalloc); FREE free = (FREE)GetProcAddress(hMSVCRT, szFree); HANDLE hModule = GetModuleHandleA(NULL); pDosHeader = (IMAGE_DOS_HEADER*)hModule; pNtHeader = (IMAGE_NT_HEADERS*)((DWORD)hModule + pDosHeader-&gt;e_lfanew); IMAGE_SECTION_HEADER* pSectionHeader = (IMAGE_SECTION_HEADER*)((DWORD)&amp;pNtHeader-&gt;OptionalHeader + pNtHeader-&gt;FileHeader.SizeOfOptionalHeader); pSectionHeader = pSectionHeader + pNtHeader-&gt;FileHeader.NumberOfSections - 1; // 获取程序数据 char* src = (char*)((DWORD)hModule + pSectionHeader-&gt;VirtualAddress + 0x2000); int srcSize = pSectionHeader-&gt;SizeOfRawData - 0x2000; // 拉伸 pDosHeader = (IMAGE_DOS_HEADER*)src; pNtHeader = (IMAGE_NT_HEADERS*)((DWORD)src + pDosHeader-&gt;e_lfanew); IMAGE_OPTIONAL_HEADER32* pOptionalHeader = &amp;pNtHeader-&gt;OptionalHeader; pSectionHeader = (IMAGE_SECTION_HEADER*)((DWORD)pOptionalHeader + pNtHeader-&gt;FileHeader.SizeOfOptionalHeader); int length = pSectionHeader[pNtHeader-&gt;FileHeader.NumberOfSections - 1].VirtualAddress + pSectionHeader[pNtHeader-&gt;FileHeader.NumberOfSections - 1].SizeOfRawData; //有时候会出现length比Image还要大 length = length &gt; pOptionalHeader-&gt;SizeOfImage ? length : pOptionalHeader-&gt;SizeOfImage; char* imageBuffer = (char*)malloc(length); memset(imageBuffer, 0, length); memcpy(imageBuffer, src, pOptionalHeader-&gt;SizeOfHeaders); for (int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; ++i) { memcpy(imageBuffer + pSectionHeader-&gt;VirtualAddress, src + pSectionHeader-&gt;PointerToRawData, pSectionHeader-&gt;SizeOfRawData); ++pSectionHeader; } char szModuleName[MAX_PATH]; GetModuleFileNameA(NULL, szModuleName, MAX_PATH); STARTUPINFO si; memset(&amp;si, 0, sizeof(si)); PROCESS_INFORMATION pi; memset(&amp;pi, 0, sizeof(pi)); si.cb = sizeof(si); CreateProcessA(NULL, szModuleName, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi); hProcess = pi.hProcess; CONTEXT context; context.ContextFlags = CONTEXT_FULL; GetThreadContext(pi.hThread, &amp;context); DWORD dwEntryPoint = context.Eax; DWORD baseAddress = context.Ebx + 8; DWORD shellImageBase = 0; ReadProcessMemory(pi.hProcess, (LPVOID)baseAddress, &amp;shellImageBase, 4, NULL); ZwUnmapViewOfSection(pi.hProcess, (PVOID)shellImageBase); LPVOID buffer = VirtualAllocEx(pi.hProcess, (LPVOID)pOptionalHeader-&gt;ImageBase, pOptionalHeader-&gt;SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (!buffer) { VirtualAllocEx(pi.hProcess, NULL, pOptionalHeader-&gt;SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); pDosHeader = (IMAGE_DOS_HEADER*)imageBuffer; pNtHeader = (IMAGE_NT_HEADERS*)((DWORD)imageBuffer + pDosHeader-&gt;e_lfanew); IMAGE_OPTIONAL_HEADER32* pOptionalHeader = &amp;pNtHeader-&gt;OptionalHeader; IMAGE_BASE_RELOCATION* pBaseRelocation = (IMAGE_BASE_RELOCATION*)((DWORD)imageBuffer + pOptionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); while (pBaseRelocation-&gt;SizeOfBlock || pBaseRelocation-&gt;VirtualAddress) { short* pTable = (short*)((int)pBaseRelocation + 8); int len = (pBaseRelocation-&gt;SizeOfBlock - 8) / 2; for (int i = 0; i &lt; len; ++i) { DWORD RVA = pBaseRelocation-&gt;VirtualAddress + (pTable[i] &amp; 0x0FFF); if (((pTable[i] &amp; 0xF000) &gt;&gt; 12) == 3) { *(DWORD*)(RVA + (DWORD)imageBuffer) += ((DWORD)buffer - pOptionalHeader-&gt;ImageBase); } } pBaseRelocation = (IMAGE_BASE_RELOCATION*)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock); } pOptionalHeader-&gt;ImageBase = (DWORD)buffer; } WriteProcessMemory(pi.hProcess, buffer, imageBuffer, pOptionalHeader-&gt;SizeOfImage, NULL); WriteProcessMemory(pi.hProcess, (LPVOID)(context.Ebx + 8), &amp;buffer, 4, NULL); context.Eax = pOptionalHeader-&gt;ImageBase + pOptionalHeader-&gt;AddressOfEntryPoint; SetThreadContext(pi.hThread, &amp;context); ResumeThread(pi.hThread); free(imageBuffer); ExitProcess(0); } catch (...) { if (hProcess) TerminateProcess(hProcess, 0); return; }}","link":"/2022/03/30/packing/"},{"title":"test","text":"","link":"/2022/03/31/test/"},{"title":"writeups&#39;","text":"write-ups- Reverse Engineering【攻防世界】reverse write-up open-source题目描述：菜鸡学逆向学得头皮发麻，终于它拿到了一段源代码 源代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(int argc, char *argv[]) { if (argc != 4) { printf(&quot;what?\\n&quot;); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(&quot;you are wrong, sorry.\\n&quot;); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(&quot;ha, you won't get it!\\n&quot;); exit(3); } if (strcmp(&quot;h4cky0u&quot;, argv[3])) { printf(&quot;so close, dude!\\n&quot;); exit(4); } printf(&quot;Brr wrrr grr\\n&quot;); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(&quot;Get your key: &quot;); printf(&quot;%x\\n&quot;, hash); return 0;} 思考：没有难度。解法：简单修改源程序，打印hash的数值即可。 12unsigned int hash = 0xcafe * 31337 + 8 * 11 + strlen(&quot;h4cky0u&quot;) - 1615810207;printf(&quot;%d\\n&quot;.hash); simple-unpack题目描述：菜鸡拿到了一个被加壳的二进制文件 思考：先检测文件类型和壳，脱壳。解法：用radin2命令检查到该文件为ELF文件，并且被加壳了。一般linux下很少有强力的壳，利用upx工具对该二进制文件进行脱壳后发现字符串字段有flag标记。 logmein题目描述：菜鸡开始接触一些基本的算法逆向了 思考： 解法：","link":"/2022/03/30/writeups/"},{"title":"Space&#39;","text":"Review- Internet Backbones in SpaceProblem: routing in LEO constellations (SN-AS) 本文主要介绍了低地球轨道LEO(Low Earth Orbit)卫星系统里的自治系统间路由选择问题。由于LEO卫星相对地面高速运行和其网络拓扑结构的快速动态变化，路由问题一直是LEO卫星网络重点解决的难题之一。本文概述性地介绍了SN(Satellite Network)的框架，当前所存在的问题，四种路由机制及其优劣。 What’s a Satellite Network？ 典型的天地一体化信息网络的拓扑结构如图所示，包含地面网络和空间网络。地面网络包括互联网和移动通信网络；空间网络包括主干网和接入网。主干网包括静止的高轨(GEO)卫星和位于本土的地面站（TN)，是一种静止的、覆盖全球的高速网络，为各接入网提供全球范围的接入服务；接入网包含中轨(MEO)、低轨(LEO)的多种卫星网络，每个卫星系统组成一个独立的自治域(autonomous system, AS)，独立地向用户提供服务(如通信、数据、传感器、定位业务)，并通过选择一个或多个卫星作为边界路由器接入主干网，实现卫星系统间组网和业务实时传输。 PIC/qhdxxbzrkxb-59-7-512-1.jpg 其中，LEO SN网络（transit provider模型）如由两部分构成，即ground segment(GST,GSL，下图中深灰色灰色圆圈，也是routing algorithm应用的地方) &amp; space segment（ISL,satellites)。转发机制很简单：the SN only forwards traffic between ground stations (GSTs)。 img 一般来说，有三种互联模型： Last-mile providers: 一种TN的替代品，可以提供其他网络通常不容易到达的地点服务。 Transit Providers（本文的目标）: 中间商通信，给部分AS提供服务，有利于（偏远地区等）建立multihomed networks。 Internet eXchange Points：作用更类似于一个switch。 Challenges of Incorporating SN into Backbone NetworkInterdomain卫星的快速移动所导致的网络拓扑急剧变化。So it requires intersatellite routing protocols for optimal path discovery between source and destination satellites. And the link-layer handover between GSTs and satellites. IntradomainBGP协议。BGP is no longer applicable due to its (in)stability; long convergence time in the face of unstable paths. Some Evaluations在《Networking in Heaven as on Earth》这篇文章（标题取得可真有意思…）里，作者分别对SpaceX的starlink星座的两个方面，即Ground-to-Satellite Connectivity和Effect on BGP announcements，进行了评估。尽管对于绝大多数纬度区域，网络连通都较为稳定，但是connect-disconnect events的数量很有可能增加BGP收敛时间和BGP update cascades。 Main Determinants of SN Routing Algorithm stability ( avoid of route churn, truncate convergence time and etc.) cost (money for satellites, back-up network and etc.) *latency* *Multipath* - A significant property of SN (has end-to-end Path Control) 《delay is not an option》仍然把Starlink作为模拟测试对象，验证了这两种属性。 “Snapshot” Routing Algorithm: 仍然保证这两种属性《ROUTING IN LEO-BASED SATELLITE NETWORKS》 routing problem的两种处理方式：the shortest path problem(minimize the latency) or multi-commodity flow problem(maximize the network throughout)。但是后者的传统计算量级过大，所以也被SPF的近似算法所替代。由于snapshot是随时变化的，网络的拥塞或者失效也随之变化，所以问题转换为网络里任何两个节点的前k个SP。考虑到拥塞和failover的情况，作者增加了$\\zeta$参数来选择路径。这是否是保证了multi-path属性？（real-time可以先从第一个走，剩下的从k-1条路径中走。） Four Models1. White-box Model (plain BGP)It takes SN-AS as a plain AS to implement BGP. Shortcomings: instability; routing updates can be overwhelming. 2. Black-box Model (WAN)It needs building redundant terrestrial connectivity between GSTs ,so it puts **the burden of stability on the SN-AS,**and it uses WAN interconnecting the GSTs. Shortcomings: expensive. 3. SCION Implementation(PCB)It has a PCBs with two segments, namely connectivity profile and a time-varying bandwidth class. Ques : I WONDER HOW IT’S IMPLEMENTED AND WHAT’S THE DIFFERENCE WITH DESIGN OF ROUTING TABLE. Shortcomings: 4. CDN-like SN(Re-routing)Re-routing (Ques: is this done by always looking for the geometrically closed GSTs?) two possible GST deployments: source/IXP Results:img Further Relevant ResearchSN-AS内部如何沟通？Problem: A routing algorithm for LEO SNs(IGP)Solution: replace routing tables with decision maps (time &amp; scalability)(this solution is datagram based, so it doesn’t need to establish connections) (the solution mainly considers the problem of GEOGRAPHICAL DISTANCE(primary) and CONGESTIONs of satellites and ISLs) theorem 1 :whether to cross polar region or not theorem 2 :whether to go higher horizontal rings or stay in the same one Routing Algorithmthree main aspects: direction estimation ：(simplify the model as a equidistant square, namely the same distance between adjacent distances) 跳数决定下一条方向，最短跳数的方向即下一跳的方向。Minimum hop metrics are decided by two vectors, $d_{h}$ and $d_v$。 123若终点与当前卫星在同一半球上 : （判断哪个半球）计算Nh与Nv。不在同一半球上：（判断哪个半球）计算Nh与Nv。 img direction enhancement Sc is in a polar region: choose the same plane, so dv is the decisive indicator wiuth dh set to zero. Sc is in the last horizontal ring before the polar region: hd is marked as primary satisfies theorem 1: cross the polar region, dv is primary. doesn’t satisfy both of the theorems: dv is primary. compare the latitudes: Sc &gt; Sn : dh is primary; otherwise dv. congestion avoidance： set a threshold value; send to the secondary direction if the primary direction is congested. failed packets: P.S. I didn’t focus on the simulations the authors did. 如何跟TN建立有效沟通？Problem: Inter-domain Satellite Routing Protocol (between SN and TNs) Solution : BGP-S (along with traditional BGP-4) Concrete Implementation: premise: Rule1. There is only one peer gateway in an AS Rule2. The routing policies that are configured for the BGP-4 are automatically adopted by BGP-S. img properties： SN 不参与路径计算。It uses BGP-4’s LocalPref value to propagate the paths it learns through the satellite network. Five Stages: img A. BGP-S Connection SetupB.1 New Path Discovery via BGP-SB.2 New Path Discovery via BGP-4对比B.1与B.2： B.3 Path WithdrawalC. BGP-S Connection TerminationRemaining Questions PAN内部是如何沟通的，为什么BGP能引起churn，但是它是path-aware同时也是稳定的？ 问题：Although a relative local preference assignment is not allowed under BGP-4, BGP-S assigning relative local preference values does not affect the integrity of the BGP-4 because there is only one network entity per AS that is allowed to perform this operation. BGP-4和BGP-S的path discovery有什么区别？ If the currently used path is withdrawn and the AS path with, the next highest local preference value is learned via BGP-4, then no action is taken. 这个操作的原因？ 在distributed datagram routing中，cross polar region的操作是一个卫星穿越极点到（same latitude, 130- longitude）吗？原因？ 为什么once failed both directions,send to 正交方向? How is reordering predictable in a SN? Terminology AppendixRoute Churnhttps://www.oreilly.com/library/view/practical-bgp/0321127005/0321127005_ch08lev1sec5.html Path-Construction Beacons (PCBs)PAN architecture(path awareness and path choice) https://www.scion-architecture.net/pdf/2017-SCION-CACM.pdf https://netsec.ethz.ch/publications/papers/adding-path-awareness.pdf CDNTier-1/2/3 NetworkTier 1网络，其英文为：Tier 1 network，意思为：一级网络。它是一个IP网络（基于IP协议），可以通过无费用互连方式（settlement -free interconnection）到达互联网上的任何其他网络，它被视为是互联网的“骨干网”。Tier 1可与其他Tier 1网络交换流量，并无须为此支付任何费用，而部分Tier 2（二级网络）和所有Tier 3（三级网络）必须为在其他网络传输流量支付费用。 QoS ParameterInter Switch LinkRouting Information Base（= Routing Table）Path HandoverReferences1：天地一体化：http://jst.tsinghuajournals.com/CN/rhhtml/20190703.htm# 2: SCION-architecture: https://www.scion-architecture.net/","link":"/2022/03/30/Space/"},{"title":"Crytography&#39;","text":"note- 密码学基础单钥密码体制密码体制的语法定义 明文消息空间M：某个字母表中的串集。 密文消息空间C：可能的密文消息级。 加密密钥空间K：可能的加密密钥集。 解密密钥空间K’：可能的解密密钥集。 有效的密钥生成算法ζ：N➡K✖K‘。 有效的加密算法E：M✖K➡C。 有效的解密算法D：C✖K’➡M。 古典密码代换密码简单的代换密码频度分析攻击 多表密码维吉尼亚密码 弗纳姆密码和一次一密 （异或运算的反运算即它自身） 换位密码通过重新排列消息中元素的位置而不改变元素本身来变换一个消息的密码称之为换位密码。 对抗频度分析技术也是非常脆弱的。 （问题：如果对最后一个分组的空格位置不清楚，那么如何解密？） 古典密码的安全性古典密码的两个基本工作原理：代换和换位。 流密码流密码强度基于 流密码框图和分类同步流密码 自同步流密码 密钥流生成器的结构和分类？？？？？？？？？？？ 密钥流的局部统计检验 快速软硬件实现的流密码算法A5 加法流密码生成器 RC4 祖冲之密码 分组密码字长为m的数字序列的代换密码。 【问号？？】 对称群又是毛线？ 数据加密标准DES 高级加密标准AES 中国商用分组密码算法分组密码的工作模式公钥密码体制基本概念单向函数 陷门单向函数 一些单向函数的例子： 多项式求根 离散对数DL 大整数分解FAC DHP RSA密码体制RSA的安全性 ElGamal密码体制椭圆曲线密码体制基于身份的密码体制中国商用密码SM2算法公钥密码体制的安全性分析消息认证和杂凑函数认证函数消息认证码杂凑函数常用杂凑函数数字签名基本概念 RSA签名体制 ElGamal签名体制 Schnorr签名体制 DSS签名标准 中国商用数字签名算法SM2 具有特殊功能的数字签名体制 密码协议基本概念 安全协议分类及基本密码协议 秘密分拆协议 密码协议的安全性","link":"/2022/07/01/Crytography/"}],"tags":[{"name":"reverse engineering","slug":"reverse-engineering","link":"/tags/reverse-engineering/"}],"categories":[]}